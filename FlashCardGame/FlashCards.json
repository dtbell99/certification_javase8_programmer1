{
	"cards": [
		{
			"question": "Name some of the benefits of Java",
			"answer": "Object oriented, encapsulation, memory management (less prone to memory leaks), huge library, secure by design (jvm sandbox), write once run anywhere, strongly typed, multithreaded, distributed computing"
		},
		{
			"question": "These are valid identifiers true or false: $objectOne, 1$objectTwo, _Object3",
			"answer": "false, identifiers can begin with letter, currency character or connecting character like underscore, but not a digit"
		},
		{
			"question": "These are valid identifiers true or false: $ObjectOne, _ObjectTwo, someObject3, someOtherObject$$99",
			"answer": "true, identifiers can begin with letter, currency character or connecting character like underscore, but not a digit"
		},
		{
			"question": "Valid identifier? : int :b;",
			"answer": "false"
		},
		{
			"question": "Valid identifier? : int -d;",
			"answer": "false"
		},
		{
			"question": "Valid identifier: int e#;",
			"answer": "false"
		},
		{
			"question": "Valid identifier: int ______2_w;",
			"answer": "true"
		},
		{
			"question": "Valid identifier? int $c;",
			"answer": "true"
		},
		{
			"question": "Valid identifier? int 2nbr;",
			"answer": "false"
		},
		{
			"question": "Valid keyword: default",
			"answer": "true"
		},
		{
			"question": "Valid keyword: strictfp",
			"answer": "true"
		},
		{
			"question": "T/F : There can be only one public class per source file?",
			"answer": "true"
		},
		{
			"question": "T/F: Classes can be made private?",
			"answer": "false"
		},
		{
			"question": "if there is a public class does the file name have to match True/False",
			"answer": "true"
		},
		{
			"question": "Files can contain multiple classes true/false",
			"answer": "true"
		},
		{
			"question": "package name has to be first line if file is in a package t/f",
			"answer": "true"
		},
		{
			"question": "T/F Multiple classes in one file can have their own package and imports?",
			"answer": "false, each file can only have 1 unique package and set of imports"
		},
		{
			"question": "T/F main() can be overloaded?",
			"answer": "True"
		},
		{
			"question": "java.util.* is valid?",
			"answer": "true, it allows all class in util to be used without specifying java.util.ClassName"
		},
		{
			"question": "This this a valid import line? static import java.lang.System.out;",
			"answer": "false, import must be first identifier"
		},
		{
			"question": "import java.* is valid?",
			"answer": "false"
		},
		{
			"question": "Name the access modifiers?",
			"answer": "public, protected, private"
		},
		{
			"question": "Name the access controls?",
			"answer": "default, public, private, protected"
		},
		{
			"question": "Name the non-access modifiers",
			"answer": "strictfp, final, abstract"
		},
		{
			"question": "Name the two access controls a class may use?",
			"answer": "default, public"
		},
		{
			"question": "T/F Default Access is the same as package level access?",
			"answer": "True"
		},
		{
			"question": "T/F strictfp can be used with final?",
			"answer": "True"
		},
		{
			"question": "T/F Classes can be both final and abstract",
			"answer": "False, these are two separate concepts, abstract classes must be extended, final means you can not extend it"
		},
		{
			"question": "T/F strictfp is a keyword and can be used to modify a class and a method but never a variable",
			"answer": "True"
		},
		{
			"question": "T/F A final keyword on a class means it can be subclassed?",
			"answer": "False, final means it can NOT be subclassed."
		},
		{
			"question": "T/F An abstract class can never be instantiated?",
			"answer": "True"
		},
		{
			"question": "Abstract classes can be executed.",
			"answer": "True, they can have public static void main and it can execute with java AbstractClass"
		},
		{
			"question": "T/F Abstract can be applied to variables",
			"answer": "False, abstract can apply to classes and methods only"
		},
		{
			"question": "T/F Abstract methods end in semicolon instead of curly brackets.",
			"answer": "True"
		},
		{
			"question": "T/F An interface is considered a contract",
			"answer": "True"
		},
		{
			"question": "T/F Abstract keyword must be applied to method signatures in the interface",
			"answer": "False, they are presumed if not specified"
		},
		{
			"question": "T/F Interfaces can have private methods",
			"answer": "False, methods must be public only"
		},
		{
			"question": "T/F Inteface methods are implicitly public and abstract?",
			"answer": "True"
		},
		{
			"question": "T/F Interfaces can only declare constants aka public static final and not instance variables.",
			"answer": "True; you can not create instance style variables in an interface."
		},
		{
			"question": "T/F Interface methods can not be marked final, strictfp, or native",
			"answer": "True"
		},
		{
			"question": "T/F An interface can extend one or more other interfaces",
			"answer": "True; it just can not anything else and cant implement another interface or class."
		},
		{
			"question": "T/F public abstract interface Rollable() is redundant?",
			"answer": "True; abstract is assumed and not necessary in signature. public is required if you dont want it to have default access"
		},
		{
			"question": "Valid Interface method? abstract public void bounce();",
			"answer": "Yes"
		},
		{
			"question": "Valid Interface method? public abstract void bounce();",
			"answer": "Yes"
		},
		{
			"question": "Valid Interface method? abstract void bounce();",
			"answer": "Yes"
		},
		{
			"question": "Valid Interface method? public void bounce();",
			"answer": "Yes"
		},
		{
			"question": "Valid Interface method? void bounce();",
			"answer": "Yes"
		},
		{
			"question": "Are these all the same? void bounce(); public void bounce(); abstract void bounce(); public abstract void bounce(); abstract public void bounce();",
			"answer": "Yes"
		},
		{
			"question": "Compiles? final void bounce();",
			"answer": "False, final and abstract can never be used"
		},
		{
			"question": "Compiles? private void bounce();",
			"answer": "False, interface methods are always public"
		},
		{
			"question": "Compiles? protected void bounce()",
			"answer": "False, interface methods are always public"
		},
		{
			"question": "T/F Interface methods are always public?",
			"answer": "True"
		},
		{
			"question": "Interface Constants Are implied public static final?",
			"answer": "True, you don't have to put them they are implied. public int, static int, final int, or any other combination are the same as regular int = blah."
		},
		{
			"question": "Interface constants must be public static final?",
			"answer": "True, they are ALWAYS even when implied, to be public, static, and final"
		},
		{
			"question": "T/F The default keyword can be used ONLY with interface method signatures not class method signatures?",
			"answer": "True"
		},
		{
			"question": "T/F default methods are public by definition, the public modifier is optional",
			"answer": "True"
		},
		{
			"question": "T/F Default methods can not be marked private, protected, static, final, or abstract",
			"answer": "True"
		},
		{
			"question": "T/F Default methods MUST have a concrete method body",
			"answer": "True"
		},
		{
			"question": "Valid default method? default void m4();",
			"answer": "False, it doesn't have a concrete method body"
		},
		{
			"question": "Valid default method? static default void m3(){;}",
			"answer": "False, default methods can not be static"
		},
		{
			"question": "Valid default method? public default void m2(){;}",
			"answer": "True"
		},
		{
			"question": "Valid default method? default int m1(){return 1;}",
			"answer": "True, here the default implies public"
		},
		{
			"question": "T/F Java 8 allows static interface methods?",
			"answer": "True; and they are implied public"
		},
		{
			"question": "T/F static interface methods are public by default, and the public modifier is optional.",
			"answer": "True"
		},
		{
			"question": "T/F static interface methods can be marked private, protected, final, or abstract",
			"answer": "false, marked or not they must be public."
		},
		{
			"question": "T/F Static interface methods must have a concrete method body?",
			"answer": "True"
		},
		{
			"question": "Valid static interface method? static int m1(){ return 42; }",
			"answer": "True"
		},
		{
			"question": "Valid static interface method? public static void m2(){ ; }",
			"answer": "True"
		},
		{
			"question": "Valid static interface method? final static void m3(){ ; }",
			"answer": "False, final is not allowed"
		},
		{
			"question": "Valid static interface method? abstract static void m4(){ ; }",
			"answer": "False, abstract is not allowed"
		},
		{
			"question": "Valid static interface method? static void m5(); ",
			"answer": "False, no method body was specified"
		},
		{
			"question": "Name the two modifiers allowed for a class.",
			"answer": "public and default (aka package private)"
		},
		{
			"question": "Name the four access modifiers for methods and variables.",
			"answer": "public, private, protected, default"
		},
		{
			"question": "How do you get the default modifier on a method or variable or class",
			"answer": "default is default, you don't put anything."
		},
		{
			"question": "What are the three ways to access a method?",
			"answer": "1) Invoke a method declared in the same class, 2) Invoke a method using a reference of a class, 3) Invoke an inherited method"
		},
		{
			"question": "T/F A method marked final in a super class can be overridden in a sub class",
			"answer": "False, compiler error cannoit override error will occur."
		},
		{
			"question": "T/F Abstract methods can exist in a non-abstract class",
			"answer": "False, if you mark a method abstract you must mark the class abstract also."
		},
		{
			"question": "T/F abstract methods in a super class can have an implementation?",
			"answer": "False, abstract methods by definition are abstract and you must implement them yourself in a subclass."
		},
		{
			"question": "T/F super class constructor is called even when not specified with super() in sub class?",
			"answer": "True; in Java the constructor from the super class is called when you instantiate the base class."
		},
		{
			"question": "T/F You can make a inherited method private in a subclass?",
			"answer": "False, you get a weaker access privilege exception at compile time."
		},
		{
			"question": "T/F Methods marked private are accessible only in that class?",
			"answer": "True"
		},
		{
			"question": "T/F Private methods in super classes are accessible in subclasses?",
			"answer": "False, only private methods are visible to the class that holds it."
		},
		{
			"question": "T/F Always look at the class first when determining access control?",
			"answer": "True, if the class isn't accessible you know the methods/variables are also not visible."
		},
		{
			"question": "T/F A method marked private can NOT be overridden?",
			"answer": "True"
		},
		{
			"question": "T/F This method signature will compile? static void public main(String[] args)",
			"answer": "False, you get identifier expected and return type required compile errors."
		},
		{
			"question": "T/F Overriding depends on inheritence",
			"answer": "True"
		},
		{
			"question": "T/F public static is the same thing as static public?",
			"answer": "True, in the method signature you can put the access modifier before or after the static or final keyword"
		},
		{
			"question": "How do you access a super class method from a subclass in a different package?",
			"answer": "Mark it public or protected so the subclass has access to it. Default WILL not work."
		},
		{
			"question": "T/F javac will compile dependencies automatically (imported classes for example).",
			"answer": "True; if you run javac on a class that imports another the compiler will recompile that other class too."
		},
		{
			"question": "T/F You can access a default variable in a superclass from a subclass?",
			"answer": "False; same method rules apply, if not public or protected you have to be in the same package to access the variable."
		},
		{
			"question": "T/F super class protected methods/variables can be accessed with a new object of that type created?",
			"answer": "False; protected only works for subclasses outside the same package. "
		},
		{
			"question": "T/F A protected member has essentially paackage level aka default access to all classes except subclasses",
			"answer": "True"
		},
		{
			"question": "T/F Subclasses outside the package can inherit a protected member?",
			"answer": "True"
		},
		{
			"question": "T/F Subclasses outside the package can instantiate and reference a superclass protected member?",
			"answer": "True; it must be accessed via the subclass dot notation otherwise instantiating the super class will fail to work on that member."
		},
		{
			"question": "T/F A class that instantiates another object which inherits a protected member can access that member?",
			"answer": "False; the subclass has access, but to all else it is private. So the compiler errors out about protected access in the original super class."
		},
		{
			"question": "T/F Default members are visible to subclasses ONLY if those subclasses are in the same package as the superclass?",
			"answer": "True"
		},
		{
			"question": "T/F Access modifiers can be applied to local variables?",
			"answer": "False, these will not compile and isn't allowed"
		},
		{
			"question": "T/F Access modifiers can be applied to instance variables?",
			"answer": "True"
		},
		{
			"question": "T/F final modifier can be applied to local variables?",
			"answer": "True, and it is the only one :)"
		},
		{
			"question": "Which of these has access (public/private/protected/default) : From the same class",
			"answer": "All, public private protected and default"
		},
		{
			"question": "Which of these has access (public/private/protected/default) : From any class in the same package",
			"answer": "Public, Protected, and Default (not private)"
		},
		{
			"question": "Which of these has access (public/private/protected/default) : From a subclass in the same package",
			"answer": "public, protected, default"
		},
		{
			"question": "Which of these has access (public/private/protected/default) : From a subclass outside the same package",
			"answer": "public, protected (through inheritence only)"
		},
		{
			"question": "Which of these has access (public/private/protected/default) : From any nonsubclass class outside the package",
			"answer": "public"
		},
		{
			"question": "T/F These two methods are the same? public void doAction(int i) public void doAction(final int i)",
			"answer": "True, the signature is the same, they both take a int.. one just makes it final but they are the same and will cause the compiler to fail on a already defined in class error."
		},
		{
			"question": "T/F Abstract methods can exist in public class declared classes?",
			"answer": "False; abstract methods require abstract classes. "
		},
		{
			"question": "T/F Abstract classes must have at least one abstract method.",
			"answer": "False, abstract classes block instantiation but don't have to have any abstract methods."
		},
		{
			"question": "T/F Abstract subclasses do not need to create another abstract signature if they intend to have THEIR subclass implement their super class abstract method?",
			"answer": "True; if a sub class is abstract is doesn't HAVE to implement the method or even mention it is not implementing it."
		},
		{
			"question": "T/F Any class that extends an abstract class must implement all abstract methods of the superclass unless the usbclass is also abstract?",
			"answer": "True"
		},
		{
			"question": "T/F Concrete means non-abstract?",
			"answer": "True"
		},
		{
			"question": "T/F Methods can be abstract and final?",
			"answer": "False"
		},
		{
			"question": "T/F Methods can be marked abstract and private?",
			"answer": "False"
		},
		{
			"question": "T/F This is a legal signature? abstract static void doAction();",
			"answer": "False; abstract methods can not be static."
		},
		{
			"question": "T/F The synchronized keyword can be used only with methods and not variables and classes?",
			"answer": "True"
		},
		{
			"question": "T/F The native keyword can be used only with methods and not variables and classes?",
			"answer": "True"
		},
		{
			"question": "T/F Native methods end in semicolons similiar to abstract methods?",
			"answer": "True"
		},
		{
			"question": "T/F strictfp is used to enforce floating points that adhere to IEEE 754?",
			"answer": "True"
		},
		{
			"question": "T/F strictfp can be applied to a class or method but never a variable?",
			"answer": "True"
		},
		{
			"question": "T/F Methods can contain one or more varargs?",
			"answer": "False, one method can only contain one vararg. "
		},
		{
			"question": "T/F Varargs can go anywhere in the parameter list of a method?",
			"answer": "False; they must go at the end if there are other parameters. "
		},
		{
			"question": "T/F Constructors can be static?",
			"answer": "False; the point of constructors is to construct a new object which is the opposite of what static methods achieve. "
		},
		{
			"question": "T/F Constructors can have return values?",
			"answer": "False"
		},
		{
			"question": "T/F Constructors must be named after the class?",
			"answer": "True"
		},
		{
			"question": "T/F Constructors can be final?",
			"answer": "False"
		},
		{
			"question": "T/F Constructors can be abstract?",
			"answer": "False"
		},
		{
			"question": "Is this valid? class Foo { Foo(int...i, String t) {} }",
			"answer": "Trick question; varargs can not be in the front of the method. "
		},
		{
			"question": "Name the two types of variables in java. ",
			"answer": "Primitives and Reference types."
		},
		{
			"question": "Name the primitive types.",
			"answer": "char, boolean, byte, short, int, long, double, float."
		},
		{
			"question": "What is the order from smallest to largest primitive integers?",
			"answer": "byte, short, int, long"
		},
		{
			"question": "T/F doubles are bigger than floats?",
			"answer": "True"
		},
		{
			"question": "T/F integer and floating point numbers in java are signed?",
			"answer": "True; the first bit 0 is positive and 1 is negative. (signed meaning positive or negative)"
		},
		{
			"question": "How many bits and bytes are in a byte?",
			"answer": "8 bits, 1 byte"
		},
		{
			"question": "How many bits and bytes are in a short?",
			"answer": "16 bits, 2 bytes"
		},
		{
			"question": "How many bits and bytes are in an int?",
			"answer": "32 bits 4 bytes"
		},
		{
			"question": "How many bits and bytes are in a long?",
			"answer": "64 bits 8 bytes"
		},
		{
			"question": "How many bits and bytes are in a float?",
			"answer": "32 bits 4 bytes"
		},
		{
			"question": "How many bits and bytes are in a double?",
			"answer": "64 bits 8 bytes"
		},
		{
			"question": "T/F Reference variables can be declared as static variables, instance variables, method parameters, or local variables?",
			"answer": "True"
		},
		{
			"question": "What is the value of s2 and s3? String s1, s2, s3 = \"Wow\";",
			"answer": "s2 is null and s3 equals wow"
		},
		{
			"question": "What is the value of i2 and i3? int i1, i2, i3 = 929;",
			"answer": "i2 is 0 and i3 is 929"
		},
		{
			"question": "Explain variable shadowing.",
			"answer": "When you pass the same name in a parameter as an instance variable. this.size = size you must use this or it doens't work. "
		},
		{
			"question": "T/F Arrays can hold both primative and object types?",
			"answer": "True; remember arrays are always objects on the heap even when they hold primatives."
		},
		{
			"question": "Is this valid? String[] myArray []; ?",
			"answer": "Yes, you can put the brackets are the beginning or end.. this is a multidimensional array."
		},
		{
			"question": "Is this valid? int myPrimaryArray []; ?",
			"answer": "Yes, the brackets can go at the end but why would you?"
		},
		{
			"question": "Explain final primative vs. final reference",
			"answer": "A final primative can't have it's value changed or a new variable assigned to it. A final reference also can't have a new variable assigned but the values inside the reference object can be changed."
		},
		{
			"question": "T/F Final references allow mutation of their instance variables.",
			"answer": "True; So long as they don't have final on those instance variabes."
		},
		{
			"question": "T/F There are no final objects, only final references?",
			"answer": "True"
		},
		{
			"question": "Explain transient variables",
			"answer": "Variables that are ignored when the object is serialized. "
		},
		{
			"question": "Explain volatile variables",
			"answer": "A variables which must reconcile its own private copy of the variable with the master copy in memory. (Not necessary for OCA8 test)."
		},
		{
			"question": "Name what can be marked static?",
			"answer": "Methods, variables, a class nested within another class, and an initialization block {}"
		},
		{
			"question": "What can not be marked static?",
			"answer": "Constructor, classes, interfaces, method local inner classes, inner class methods and instance variables, local variables"
		},
		{
			"question": "T/F An enum can have a public constructor?",
			"answer": "False"
		},
		{
			"question": "T/F Enum in another class must be referenced with ClassName. just like static?",
			"answer": "True"
		},
		{
			"question": "T/F Enum can be created inside a method?",
			"answer": "False, only in its own file or in a class outside a method."
		},
		{
			"question": "What method do all enums have?",
			"answer": "values() ; this returns the enums in an array in the order they were created."
		},
		{
			"question": "Explain a enum constant specific class body.",
			"answer": "Similar to the look of an anonymous inner class you add { override method code } after the () to override methods in the enum."
		},
		{
			"question": "T/F Classes implement interfaces, interfaces extend other interfaces, classes extend other classes",
			"answer": "True"
		},
		{
			"question": "T/F You can extend a class from a class and an interface from an interface only?",
			"answer": "True"
		},
		{
			"question": "Explain implements vs. extends",
			"answer": "You implement one or more interfaces in a class. You extend a base class in a subclass. "
		},
		{
			"question": "Is x true or false? int x = 0; ++x == 1;",
			"answer": "True; ++ in front as opposed to x++ means the value is increased then evaluated. "
		},
		{
			"question": "What are the two most common reasons for using inheritence?",
			"answer": "Polymorphism and code reuse."
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		},
		{
			"question": "",
			"answer": ""
		}
	]
}